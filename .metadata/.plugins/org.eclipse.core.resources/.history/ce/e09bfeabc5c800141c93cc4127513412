/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package chirpBoidsSim;

import java.util.ArrayList;

import no.ntnu.idi.chirp.rxtx.RxtxClass;
import no.ntnu.idi.chirp.rxtx.RxtxListener;

import org.newdawn.slick.Graphics;
import org.newdawn.slick.geom.Vector2f;
/** 
 * @author HD
 */
public class ChirpBot implements RxtxListener{

	private Vector2f pos,vel;
	private ChirpBoidWatcher cbw;
	private float currentAngle; // in radians
	private String ID;
	private RxtxClass rxtx = null;
	private int timeSinceLastRxTx = 0;
	private int rxtxUpdateTime = 16*10; //we need to have 160 here or else the robot will not be able to process the data fast enough
	private boolean canSend;
	private boolean quit;
	/*
	 * double speed = 0; double mxspd = 50; double accel = 1000000000; double
	 * deacc = 15; double turn = 0; double mxturn = 1; double lookAhead = mxspd
	 * * 4; Robot robotAhead;
	 */

	// for catching orbit behavoirs
	public void dataReceived(float x, float y){
		vel.x = x; vel.y = y;
		System.out.println(vel.x + "   " + vel.y);
	}

	public void robotIsReady() {
		canSend = true;
	}
	
	
	public String getID() {
		return ID;
	}
	public void setID(String ID) {
		this.ID = ID;
	}
	
	public void setRxtx(RxtxClass rxtx) {
		this.rxtx = rxtx;
		rxtx.setChirpBotListener(this);
	}
	
	public RxtxClass getRxtx(){
		return rxtx;
	}

	public ChirpBot(float initX, float initY, float initAngle,
			String id, ChirpBoidWatcher cbw) {
		this.cbw = cbw;
		pos = new Vector2f(initX, initY);
		vel = new Vector2f(0, 0);
		currentAngle = initAngle;
		ID = id;
		canSend = true;
		quit = false;
		
	}
	
	
	float sumX = 0;
	float sumY = 0;
	int posCount = 1;
	int AVG = 3;
	public void setPosition(float x, float y){
		if(cbw.averaging){
			if(posCount++ % AVG == 0){
				pos.x = (x+sumX) / (float)AVG;
				pos.y = (y+sumY) / (float)AVG;
				sumX = 0;
				sumY = 0;
			}
			else{
				sumX += x;
				sumY += y;		
			}
		}
		else{
			pos.x = x;
			pos.y = y;
		}
		
	}
	
	private float sumAngle = 0;
	private int angleCount = 1;
	
	public void setAngle(float angle){
		if(cbw.averaging){
			if(angleCount++ % AVG == 0){
				currentAngle = (angle+sumAngle)/AVG;
				sumAngle = 0;
			}
			else{
				sumAngle += angle;
			}
		}
		else
			currentAngle = angle;
	}
	
	
	public void draw(Graphics g) {
//			g.setColor(Color.cyan);
//		else if(getCol() == 0)
//			g.setColor(Color.white);
//		else
//			g.setColor(Color.yellow);
		g.drawString(getID(), getX(), getY());
		g.drawString(pos.x + "," + pos.y, getX(), getY()+12);
//		g.drawString(getID(), getX(), getY()+24);
		g.drawOval(getX()-cbw.size/2, getY()-cbw.size/2, cbw.size, cbw.size);
		if(rxtx != null) g.drawString(ID+"-"+rxtx.portName.substring(7)+"", (float)getX(), (float)getY());
		float a = currentAngle;
		g.drawLine(getX(), getY(), (float) (pos.x + cbw.size/2 * Math.cos(a) + Math.sin(a)), (float)(pos.y + cbw.size/2 * Math.sin(a) - Math.cos(a)));
		
	}
	
	private void tempMove(long delta){
		pos.x += vel.x/delta;
		pos.y += vel.y/delta;
		if(pos.x > cbw.w)
			pos.x = 0;
		if(pos.x < 0)
			pos.x = cbw.w;
		if(pos.y > cbw.h)
			pos.y = 0;
		if(pos.y < 0)
			pos.y = cbw.h;
	}
	public void update(long delta) {
		refractor();
		
		tempMove(delta);
		
//		int[] motorSpeed = {0,0};//getMotor();
		timeSinceLastRxTx += delta;
		if(timeSinceLastRxTx < rxtxUpdateTime)
		{
			return;
		}
		else timeSinceLastRxTx = 0;
		
		if(rxtx != null && canSend) {
			/* 3 floats for posx, posy, angle
			*  4 floats for each OTHER chirpBots, because the first 3 bytes already have been used for "this".
			*  4 floats; posx, posy, velx, vely;
			*/
			ArrayList<Float> data = new ArrayList<Float>();//float[3+(cbw.prototype.size()-1)*4];
//			tempData(data);
			data.add(getX());
			data.add(getY());
			data.add(getAngle());
			
			for (int i = 0; i < cbw.prototype.size(); i++) {
				ChirpBot current =  cbw.prototype.get(i);
				if(current == this)
					continue;
				data.add(current.getX());
				data.add(current.getY());
				data.add(current.getVelX());
				data.add(current.getVelY());
			}
//			System.out.println("attempting to send data");
			if(!quit)
				rxtx.sendBoidData(data);
			
			canSend = false;
			
//			rxtx.sendRobotData(motorSpeed[0], motorSpeed[1]);
		}
	}
	
	public boolean quit(){
		quit = true;
		if(rxtx == null)
			return true;
		if(canSend){
			rxtx.sendSingleByte((byte) 0);
			return true;
		}
		return false;
	}
	
	private void tempData(ArrayList<Float> d){
		for (int i = 0; i < 15; i++) {
			d.add((float)i);
		}
	}
	

	public float getVelX() {
		return vel.x;
	}
	public float getVelY() {
		return vel.y;
		
	}
	private void refractor() { // makes sure that the angle is always inside
								// [-PI, PI]
		if (currentAngle > Math.PI) {
			currentAngle -= 2 * Math.PI;
		} else if (currentAngle < -Math.PI) {
			currentAngle += 2 * Math.PI;
		}
	}


	/**
	 * GETTERS
	 * 
	 * 
	 */
	public float getX() {
		return pos.x;
	}

	public float getY() {
		return pos.y;
	}

	public float getAngle() {
			return currentAngle;
		
	}

	public void randomize() {
		pos.x = (float)Math.random()*cbw.w;
		pos.y = (float)Math.random()*cbw.h;
		
	}



}
